<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<title>Plotters</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="docs.css" rel="stylesheet" />
<script src="site_libs/htmlwidgets-0.8/htmlwidgets.js"></script>
<link href="site_libs/dygraphs-1.1.1/dygraph.css" rel="stylesheet" />
<script src="site_libs/dygraphs-1.1.1/dygraph-combined.js"></script>
<script src="site_libs/dygraphs-1.1.1/shapes.js"></script>
<script src="site_libs/moment-2.8.4/moment.js"></script>
<script src="site_libs/moment-timezone-0.2.5/moment-timezone-with-data.js"></script>
<script src="site_libs/moment-fquarter-1.0.0/moment-fquarter.min.js"></script>
<script src="site_libs/dygraphs-binding-1.1.1.4/dygraphs.js"></script>
<script src="site_libs/Dygraph.Plotters.BarChart-1.0/barchart.js"></script>
<script src="site_libs/Dygraph.Plotters.MultiColumn-1.0/multicolumn.js"></script>

<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>
</head>

<body>
<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->
<div class="row-fluid">

<div class="col-md-3">
  
<ul class="nav nav-list well sidebar-nav sidebar-nav-fixed">
  
  <h4>dygraphs for R</h4>
  
  <li><a href="index.html">Home</a></li>
  
  <li class="nav-header">Using</li>
  <li><a href="r-console.html">R Console</a></li>
  <li><a href="r-markdown.html">R Markdown</a></li>
  <li><a href="shiny.html">Shiny</a></li>
  
  <li class="nav-header">Gallery</li>
  <li><a href="gallery-series-options.html">Series Options</a></li>
  <li><a href="gallery-series-highlighting.html">Series Highlighting</a></li>
  <li><a href="gallery-axis-options.html">Axis Options</a></li>
  <li><a href="gallery-plot-labels.html">Labels &amp; Legends</a></li>
  <li><a href="gallery-timezones.html">Time Zones</a></li>
  <li><a href="gallery-css-styling.html">CSS Styling</a></li>
  <li><a href="gallery-range-selector.html">Range Selector</a></li>
  <li><a href="gallery-candlestick.html">Candlestick Charts</a></li>
  <li><a href="gallery-synchronization.html">Synchronization</a></li>
  <li><a href="gallery-straw-broom.html">Straw Broom Charts</a></li>
  <li><a href="gallery-roll-periods.html">Roll Periods</a></li>
  <li><a href="gallery-annotations.html">Annotation/Shading</a></li>
  <li><a href="gallery-event-lines.html">Events and Limits</a></li>
  <li><a href="gallery-upper-lower-bars.html">Upper/Lower Bars</a></li>
  <li><a href="gallery-plugins.html">Plugins</a></li>
  <li><a href="gallery-custom-plotters.html">Custom Plotters</a></li>
  <li><a href="gallery-ribbon.html">Colored Ribbon</a></li>
</ul>
  
</div>
  
<div class="col-md-9">

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Plotters</h1>

</div>


<p>You can use dygraphs plotters to customize the appearance of dygraphs.</p>
<p>Once you’ve created a dygraphs plotter you can use the <code>dyPlotter</code> function to create an R wrapper function for it. Examples of R wrappers for two simple dygraphs plotters are provided below.</p>
<div id="bar-chart" class="section level4">
<h4>Bar Chart</h4>
<p>This plotter draws a bar plot rather a line plot.</p>
<p>Here’s how you’d create an R function to wrap the Bar Chart plotter:</p>
<pre class="r"><code>dyBarChart &lt;- function(dygraph) {
  dyPlotter(dygraph = dygraph,
            name = &quot;BarChart&quot;,
            path = system.file(&quot;plotters/barchart.js&quot;,
                               package = &quot;dygraphs&quot;))
}</code></pre>
<p>The plotter can now be used directly within a dygraph pipeline along with other dygraphs functions:</p>
<pre class="r"><code>dygraph(ldeaths) %&gt;%
  dyRangeSelector() %&gt;%
  dyBarChart()</code></pre>
<div id="htmlwidget-70fc72d266d57ba9b9ed" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-70fc72d266d57ba9b9ed">{"x":{"attrs":{"labels":["month","V1"],"legend":"auto","retainDateWindow":false,"axes":{"x":{"pixelsPerLabel":60}},"showRangeSelector":true,"rangeSelectorHeight":40,"rangeSelectorPlotFillColor":" #A7B1C4","rangeSelectorPlotStrokeColor":"#808FAB","interactionModel":"Dygraph.Interaction.defaultModel"},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[3035,2552,2704,2554,2014,1655,1721,1524,1596,2074,2199,2512,2933,2889,2938,2497,1870,1726,1607,1545,1396,1787,2076,2837,2787,3891,3179,2011,1636,1580,1489,1300,1356,1653,2013,2823,3102,2294,2385,2444,1748,1554,1498,1361,1346,1564,1640,2293,2815,3137,2679,1969,1870,1633,1529,1366,1357,1570,1535,2491,3084,2605,2573,2143,1693,1504,1461,1354,1333,1492,1781,1915]],"plotter":"BarChart"},"evals":["attrs.interactionModel"],"jsHooks":[]}</script>
</div>
<div id="multi-column-bar-chart" class="section level4">
<h4>Multi-column Bar Chart</h4>
<p>This plotter draws multiple column bar chart.</p>
<p>Here’s how you’d create an R function to wrap the Bar Chart plotter:</p>
<pre class="r"><code>dyMultiColumn &lt;- function(dygraph) {
  dyPlotter(dygraph = dygraph,
            name = &quot;MultiColumn&quot;,
            path = system.file(&quot;plotters/multicolumn.js&quot;,
                               package = &quot;dygraphs&quot;))
}</code></pre>
<p>The plotter can now be used directly within a dygraph pipeline along with other dygraphs functions:</p>
<pre class="r"><code>lungDeaths &lt;- cbind(mdeaths, fdeaths)
dygraph(lungDeaths) %&gt;%
  dyRangeSelector() %&gt;%
  dyMultiColumn()</code></pre>
<div id="htmlwidget-5b65f82ecf40cdf73483" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-5b65f82ecf40cdf73483">{"x":{"attrs":{"labels":["month","mdeaths","fdeaths"],"legend":"auto","retainDateWindow":false,"axes":{"x":{"pixelsPerLabel":60}},"showRangeSelector":true,"rangeSelectorHeight":40,"rangeSelectorPlotFillColor":" #A7B1C4","rangeSelectorPlotStrokeColor":"#808FAB","interactionModel":"Dygraph.Interaction.defaultModel"},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574]],"plotter":"MultiColumn"},"evals":["attrs.interactionModel"],"jsHooks":[]}</script>
</div>
<div id="series-plotters" class="section level4">
<h4>Series Plotters</h4>
<p>While the above plotters act on all the underlying data of the dygraph, you can also use variations of the plotters to act on only a single series. Several variations come with the <code>dygraphs</code> package.</p>
<pre class="r"><code>lungDeaths &lt;- cbind(mdeaths, fdeaths)
dygraph(lungDeaths) %&gt;%
  dyRangeSelector() %&gt;%
  dyBarSeries(&#39;fdeaths&#39;) %&gt;% 
  dyFilledLine(&#39;mdeaths&#39;)</code></pre>
<div id="htmlwidget-10d3d002a811f92b5cbe" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-10d3d002a811f92b5cbe">{"x":{"attrs":{"labels":["month","fdeaths","mdeaths"],"legend":"auto","retainDateWindow":false,"axes":{"x":{"pixelsPerLabel":60}},"showRangeSelector":true,"rangeSelectorHeight":40,"rangeSelectorPlotFillColor":" #A7B1C4","rangeSelectorPlotStrokeColor":"#808FAB","interactionModel":"Dygraph.Interaction.defaultModel","series":{"fdeaths":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction barChartPlotter(e) {\n  var ctx = e.drawingContext;\n  var points = e.points;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  ctx.fillStyle = e.color;\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // Do the actual plotting.\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    var center_x = p.canvasx;\n\n    ctx.fillRect(center_x - bar_width / 2, p.canvasy,\n      bar_width, y_bottom - p.canvasy);\n\n    ctx.strokeRect(center_x - bar_width / 2, p.canvasy,\n      bar_width, y_bottom - p.canvasy);\n  }\n}\n"},"mdeaths":{"axis":"y","plotter":"// the _fillplotter combined with the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction filledlineplotter(e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n\n  var fillAlpha = g.getNumericOption('fillAlpha');\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  var ctx = e.drawingContext;\n\n  var stepPlot = g.getBooleanOption('stepPlot', setName);\n  var color = e.color\n  var axis = g.axisPropertiesForSeries(setName);\n  var axisY = 1.0 + axis.minyval * axis.yscale;\n  if (axisY < 0.0) axisY = 0.0;\n  else if (axisY > 1.0) axisY = 1.0;\n  axisY = area.h * axisY + area.y;\n\n  var points = e.points;\n  var iter = Dygraph.createIterator(points, 0, points.length,\n      DygraphCanvasRenderer._getIteratorPredicate(\n          g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevYs = [-1, -1];\n  var newYs;\n  // should be same color as the lines but only 15% opaque.\n  var rgb = Dygraph.toRGB_(color);\n  var err_color =\n      'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n  var last_x, is_first = true;\n\n  // If the point density is high enough, dropping segments on their way to\n  // the canvas justifies the overhead of doing so.\n  if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n    ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n  }\n\n  // For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n  // TODO(danvk): there are a lot of options at play in this loop.\n  //     The logic would be much clearer if some (e.g. stackGraph and\n  //     stepPlot) were split off into separate sub-plotters.\n  var point;\n  while (iter.hasNext) {\n    point = iter.next();\n    if (!Dygraph.isOK(point.y) && !stepPlot) {\n      traceBackPath(ctx, prevX, prevYs[1], pathBack);\n      pathBack = [];\n      prevX = NaN;\n      if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n        baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n      }\n      continue;\n    }\n    \n      if (isNaN(point.canvasy) && stepPlot) {\n        newYs = [ area.y + area.h, axisY ];\n      } else {\n        newYs = [ point.canvasy, axisY ];\n      }\n      \n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      \n      prevYs = newYs;\n      prevX = point.canvasx;\n      \n    }\n    \n    prevStepPlot = stepPlot;\n    \n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    \n    ctx.fill();\n    \n  //now execute the basic line plotter... per precedence noted in dygraph-combined-dev.js\n  DygraphCanvasRenderer._linePlotter(e);\n}"}}},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341]]},"evals":["attrs.interactionModel","attrs.series.fdeaths.plotter","attrs.series.mdeaths.plotter"],"jsHooks":[]}</script>
</div>
<div id="grouped-series-plotters" class="section level4">
<h4>Grouped Series Plotters</h4>
<p><code>dygraphs</code> comes packaged with a number of group-based plotters.</p>
<p>Similar to working with just a single series, you can also use custom plotters on a group of data series from the underlying data. Check the documentation under <code>Plotters</code> for more inspiration.</p>
<pre class="r"><code>lungDeaths &lt;- cbind(mdeaths, fdeaths, ldeaths)
dygraph(lungDeaths) %&gt;%
  dyStackedBarGroup(c(&#39;ldeaths&#39;, &#39;mdeaths&#39;))</code></pre>
<div id="htmlwidget-f4586241af40bc5776ab" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-f4586241af40bc5776ab">{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60},"y":{"valueRange":[0,6973.05]}},"series":{"ldeaths":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"ldeathsmdeaths"},"mdeaths":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"ldeathsmdeaths"}},"labels":["month","fdeaths","ldeaths","mdeaths"],"legend":"auto","retainDateWindow":false},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574],[3035,2552,2704,2554,2014,1655,1721,1524,1596,2074,2199,2512,2933,2889,2938,2497,1870,1726,1607,1545,1396,1787,2076,2837,2787,3891,3179,2011,1636,1580,1489,1300,1356,1653,2013,2823,3102,2294,2385,2444,1748,1554,1498,1361,1346,1564,1640,2293,2815,3137,2679,1969,1870,1633,1529,1366,1357,1570,1535,2491,3084,2605,2573,2143,1693,1504,1461,1354,1333,1492,1781,1915],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341]]},"evals":["attrs.series.ldeaths.plotter","attrs.series.mdeaths.plotter"],"jsHooks":[]}</script>
<pre class="r"><code>dygraph(lungDeaths) %&gt;%
  dyMultiColumnGroup(c(&#39;mdeaths&#39;, &#39;fdeaths&#39;))</code></pre>
<div id="htmlwidget-e95d9db97b6a636a754d" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-e95d9db97b6a636a754d">{"x":{"attrs":{"labels":["month","ldeaths","mdeaths","fdeaths"],"legend":"auto","retainDateWindow":false,"axes":{"x":{"pixelsPerLabel":60}},"series":{"mdeaths":{"axis":"y","plotter":"/**\n * Multi-column Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n * \n * Modified to apply only to a supplied group of sets\n */\n\n  // Multiple column bar chart\nfunction multiColumnGroupPlotter(e) {\n\n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  for (var j = 0; j < sets.length; j++) {\n    var points = sets[j];\n    for (var i = 1; i < points.length; i++) {\n      var sep = points[i].canvasx - points[i - 1].canvasx;\n      if (sep < min_sep) min_sep = sep;\n    }\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  for (var i = 0; i < groupIdx.length; i++) {\n    fillColors.push(strokeColors[groupIdx[i]]);\n  }\n\n  for (var j = 0; j < sets.length; j++) {\n    ctx.fillStyle = fillColors[j];\n    ctx.strokeStyle = strokeColors[j];\n    for (var i = 0; i < sets[j].length; i++) {\n      var p = sets[j][i];\n      var center_x = p.canvasx;\n      var x_left = center_x - (bar_width / 2) * (1 - j/(sets.length-1));\n\n      ctx.fillRect(x_left, p.canvasy,\n        bar_width/sets.length, y_bottom - p.canvasy);\n\n      ctx.strokeRect(x_left, p.canvasy,\n        bar_width/sets.length, y_bottom - p.canvasy);\n    }\n  }\n}","group":"mdeathsfdeaths"},"fdeaths":{"axis":"y","plotter":"/**\n * Multi-column Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n * \n * Modified to apply only to a supplied group of sets\n */\n\n  // Multiple column bar chart\nfunction multiColumnGroupPlotter(e) {\n\n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  for (var j = 0; j < sets.length; j++) {\n    var points = sets[j];\n    for (var i = 1; i < points.length; i++) {\n      var sep = points[i].canvasx - points[i - 1].canvasx;\n      if (sep < min_sep) min_sep = sep;\n    }\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  for (var i = 0; i < groupIdx.length; i++) {\n    fillColors.push(strokeColors[groupIdx[i]]);\n  }\n\n  for (var j = 0; j < sets.length; j++) {\n    ctx.fillStyle = fillColors[j];\n    ctx.strokeStyle = strokeColors[j];\n    for (var i = 0; i < sets[j].length; i++) {\n      var p = sets[j][i];\n      var center_x = p.canvasx;\n      var x_left = center_x - (bar_width / 2) * (1 - j/(sets.length-1));\n\n      ctx.fillRect(x_left, p.canvasy,\n        bar_width/sets.length, y_bottom - p.canvasy);\n\n      ctx.strokeRect(x_left, p.canvasy,\n        bar_width/sets.length, y_bottom - p.canvasy);\n    }\n  }\n}","group":"mdeathsfdeaths"}}},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[3035,2552,2704,2554,2014,1655,1721,1524,1596,2074,2199,2512,2933,2889,2938,2497,1870,1726,1607,1545,1396,1787,2076,2837,2787,3891,3179,2011,1636,1580,1489,1300,1356,1653,2013,2823,3102,2294,2385,2444,1748,1554,1498,1361,1346,1564,1640,2293,2815,3137,2679,1969,1870,1633,1529,1366,1357,1570,1535,2491,3084,2605,2573,2143,1693,1504,1461,1354,1333,1492,1781,1915],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574]]},"evals":["attrs.series.mdeaths.plotter","attrs.series.fdeaths.plotter"],"jsHooks":[]}</script>
<pre class="r"><code>lungDeaths &lt;- cbind(mdeaths, fdeaths, ldeaths, adjustment = 100)
dygraph(lungDeaths) %&gt;%
  dyStackedRibbonGroup(c(&#39;fdeaths&#39;, &#39;ldeaths&#39;)) %&gt;% 
  dyStackedBarGroup(c(&#39;adjustment&#39;, &#39;mdeaths&#39;))</code></pre>
<div id="htmlwidget-845d27f93edf19df0ed2" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-845d27f93edf19df0ed2">{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60},"y":{"valueRange":[0,5547.78]}},"series":{"fdeaths":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = fillColors[j];\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"fdeathsldeaths"},"ldeaths":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = fillColors[j];\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"fdeathsldeaths"},"adjustment":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"adjustmentmdeaths"},"mdeaths":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"adjustmentmdeaths"}},"labels":["month","fdeaths","ldeaths","adjustment","mdeaths"],"legend":"auto","retainDateWindow":false},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574],[3035,2552,2704,2554,2014,1655,1721,1524,1596,2074,2199,2512,2933,2889,2938,2497,1870,1726,1607,1545,1396,1787,2076,2837,2787,3891,3179,2011,1636,1580,1489,1300,1356,1653,2013,2823,3102,2294,2385,2444,1748,1554,1498,1361,1346,1564,1640,2293,2815,3137,2679,1969,1870,1633,1529,1366,1357,1570,1535,2491,3084,2605,2573,2143,1693,1504,1461,1354,1333,1492,1781,1915],[100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341]]},"evals":["attrs.series.fdeaths.plotter","attrs.series.ldeaths.plotter","attrs.series.adjustment.plotter","attrs.series.mdeaths.plotter"],"jsHooks":[]}</script>
</div>
<div id="mix-and-match" class="section level4">
<h4>Mix-and-match</h4>
<p>Use the plotters to highlight different series, stack only related groups, or whatever!</p>
<pre class="r"><code>lungDeaths &lt;- cbind(ldeaths, fdeaths, mdeaths,
                    additive = rep.int(200, length(ldeaths)),
                    line = rep.int(3000, length(ldeaths)))
dygraph(lungDeaths) %&gt;%
  dySeries(&#39;line&#39;, strokePattern = &#39;dashed&#39;) %&gt;%
  dySeries(&#39;ldeaths&#39;, stepPlot = TRUE) %&gt;%
  dyStackedBarGroup(c(&#39;additive&#39;, &#39;mdeaths&#39;)) %&gt;%
  dyStackedRibbonGroup(c(&#39;fdeaths&#39;, &#39;ldeaths&#39;))</code></pre>
<div id="htmlwidget-d01742d830dda371557e" style="width:624px;height:336px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-d01742d830dda371557e">{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60},"y":{"valueRange":[0,5283.6]}},"series":{"line":{"axis":"y","strokePattern":[7,3]},"ldeaths":{"stepPlot":true,"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = fillColors[j];\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"fdeathsldeaths"},"additive":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"additivemdeaths"},"mdeaths":{"axis":"y","plotter":"/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var y_bottom = e.dygraph.toDomYCoord(0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var axis;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}","group":"additivemdeaths"},"fdeaths":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = fillColors[j];\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"fdeathsldeaths"}},"labels":["month","line","additive","mdeaths","fdeaths","ldeaths"],"legend":"auto","retainDateWindow":false},"scale":"monthly","annotations":[],"shadings":[],"events":[],"format":"date","data":[["1974-01-01T00:00:00.000Z","1974-02-01T00:00:00.000Z","1974-03-01T00:00:00.000Z","1974-04-01T00:00:00.000Z","1974-05-01T00:00:00.000Z","1974-06-01T00:00:00.000Z","1974-07-01T00:00:00.000Z","1974-08-01T00:00:00.000Z","1974-09-01T00:00:00.000Z","1974-10-01T00:00:00.000Z","1974-11-01T00:00:00.000Z","1974-12-01T00:00:00.000Z","1975-01-01T00:00:00.000Z","1975-02-01T00:00:00.000Z","1975-03-01T00:00:00.000Z","1975-04-01T00:00:00.000Z","1975-05-01T00:00:00.000Z","1975-06-01T00:00:00.000Z","1975-07-01T00:00:00.000Z","1975-08-01T00:00:00.000Z","1975-09-01T00:00:00.000Z","1975-10-01T00:00:00.000Z","1975-11-01T00:00:00.000Z","1975-12-01T00:00:00.000Z","1976-01-01T00:00:00.000Z","1976-02-01T00:00:00.000Z","1976-03-01T00:00:00.000Z","1976-04-01T00:00:00.000Z","1976-05-01T00:00:00.000Z","1976-06-01T00:00:00.000Z","1976-07-01T00:00:00.000Z","1976-08-01T00:00:00.000Z","1976-09-01T00:00:00.000Z","1976-10-01T00:00:00.000Z","1976-11-01T00:00:00.000Z","1976-12-01T00:00:00.000Z","1977-01-01T00:00:00.000Z","1977-02-01T00:00:00.000Z","1977-03-01T00:00:00.000Z","1977-04-01T00:00:00.000Z","1977-05-01T00:00:00.000Z","1977-06-01T00:00:00.000Z","1977-07-01T00:00:00.000Z","1977-08-01T00:00:00.000Z","1977-09-01T00:00:00.000Z","1977-10-01T00:00:00.000Z","1977-11-01T00:00:00.000Z","1977-12-01T00:00:00.000Z","1978-01-01T00:00:00.000Z","1978-02-01T00:00:00.000Z","1978-03-01T00:00:00.000Z","1978-04-01T00:00:00.000Z","1978-05-01T00:00:00.000Z","1978-06-01T00:00:00.000Z","1978-07-01T00:00:00.000Z","1978-08-01T00:00:00.000Z","1978-09-01T00:00:00.000Z","1978-10-01T00:00:00.000Z","1978-11-01T00:00:00.000Z","1978-12-01T00:00:00.000Z","1979-01-01T00:00:00.000Z","1979-02-01T00:00:00.000Z","1979-03-01T00:00:00.000Z","1979-04-01T00:00:00.000Z","1979-05-01T00:00:00.000Z","1979-06-01T00:00:00.000Z","1979-07-01T00:00:00.000Z","1979-08-01T00:00:00.000Z","1979-09-01T00:00:00.000Z","1979-10-01T00:00:00.000Z","1979-11-01T00:00:00.000Z","1979-12-01T00:00:00.000Z"],[3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000],[200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200],[2134,1863,1877,1877,1492,1249,1280,1131,1209,1492,1621,1846,2103,2137,2153,1833,1403,1288,1186,1133,1053,1347,1545,2066,2020,2750,2283,1479,1189,1160,1113,970,999,1208,1467,2059,2240,1634,1722,1801,1246,1162,1087,1013,959,1179,1229,1655,2019,2284,1942,1423,1340,1187,1098,1004,970,1140,1110,1812,2263,1820,1846,1531,1215,1075,1056,975,940,1081,1294,1341],[901,689,827,677,522,406,441,393,387,582,578,666,830,752,785,664,467,438,421,412,343,440,531,771,767,1141,896,532,447,420,376,330,357,445,546,764,862,660,663,643,502,392,411,348,387,385,411,638,796,853,737,546,530,446,431,362,387,430,425,679,821,785,727,612,478,429,405,379,393,411,487,574],[3035,2552,2704,2554,2014,1655,1721,1524,1596,2074,2199,2512,2933,2889,2938,2497,1870,1726,1607,1545,1396,1787,2076,2837,2787,3891,3179,2011,1636,1580,1489,1300,1356,1653,2013,2823,3102,2294,2385,2444,1748,1554,1498,1361,1346,1564,1640,2293,2815,3137,2679,1969,1870,1633,1529,1366,1357,1570,1535,2491,3084,2605,2573,2143,1693,1504,1461,1354,1333,1492,1781,1915]]},"evals":["attrs.series.ldeaths.plotter","attrs.series.additive.plotter","attrs.series.mdeaths.plotter","attrs.series.fdeaths.plotter"],"jsHooks":[]}</script>
</div>


</div>  
</div>

<script>

// manage active state of toc based on current page
$(document).ready(function () {
    // active menu
    href = window.location.pathname;
    href = href.substr(href.lastIndexOf('/') + 1);
    if (href == "")
      href = "index.html";
    $('a[href="' + href + '"]').parent().addClass('active');
});

</script>

<!-- Fork me on Github Button -->

<a id="github-link" href="https://github.com/rstudio/dygraphs"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>
</body>
</html>
